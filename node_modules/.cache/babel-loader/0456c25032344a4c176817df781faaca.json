{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass JSONDigger {\n  constructor(datasource, idProp, childrenProp) {\n    this.ds = datasource;\n    this.id = idProp;\n    this.children = childrenProp;\n    this.count = 0;\n  }\n\n  countNodes(obj) {\n    var _this = this;\n\n    this.count++;\n\n    if (!obj || !Object.keys(obj).length) {\n      return false;\n    } else {\n      if (obj[this.children]) {\n        obj[this.children].forEach(child => {\n          _this.countNodes(child);\n        });\n      }\n    }\n  }\n\n  findNodeById(id) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      function findNodeById(obj, id, callback) {\n        if (!_this.count) {\n          return;\n        }\n\n        if (obj[_this.id] === id) {\n          _this.count = 0;\n          callback(null, obj);\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback('The node doesn\\'t exist.', null);\n          }\n\n          _this.count--;\n\n          if (obj[_this.children]) {\n            obj[_this.children].forEach(node => {\n              findNodeById(node, id, callback);\n            });\n          }\n        }\n      }\n\n      findNodeById(this.ds, id, (msg, node) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(node);\n        }\n      });\n    });\n  }\n\n  matchConditions(obj, conditions) {\n    var flag = true;\n    Object.keys(conditions).some(item => {\n      if (typeof conditions[item] === 'string' || typeof conditions[item] === 'number' || typeof conditions[item] === 'boolean') {\n        if (obj[item] !== conditions[item]) {\n          flag = false;\n          return true;\n        }\n      } else if (conditions[item] instanceof RegExp) {\n        if (!conditions[item].test(obj[item])) {\n          flag = false;\n          return true;\n        }\n      } else if (typeof conditions[item] === 'object') {\n        Object.keys(conditions[item]).some(subitem => {\n          switch (subitem) {\n            case '>':\n              {\n                if (!(obj[item] > conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '<':\n              {\n                if (!(obj[item] < conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '>=':\n              {\n                if (!(obj[item] >= conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '<=':\n              {\n                if (!(obj[item] <= conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '!==':\n              {\n                if (!(obj[item] !== conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n          }\n        });\n\n        if (!flag) {\n          return false;\n        }\n      }\n    });\n    return flag;\n  }\n\n  async findChildren(id) {\n    const _this = this;\n\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    try {\n      const parent = await this.findParent(id);\n      return parent[this.children];\n    } catch (err) {\n      throw new Error('The child nodes don\\'t exist.');\n    }\n  }\n\n  findNodes(conditions) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise(async (resolve, reject) => {\n      if (!conditions || !Object.keys(conditions).length) {\n        return reject(new Error('Parameter conditions are invalid.'));\n      }\n\n      let nodes = [];\n\n      function findNodes(obj, conditions, callback) {\n        if (!_this.count) {\n          return;\n        }\n\n        if (_this.matchConditions(obj, conditions)) {\n          nodes.push(obj);\n\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n          }\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n          }\n        }\n\n        _this.count--;\n\n        if (obj[_this.children]) {\n          obj[_this.children].forEach(child => {\n            findNodes(child, conditions, callback);\n          });\n        }\n      }\n\n      findNodes(this.ds, conditions, (msg, nodes) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(nodes);\n        }\n      });\n    });\n  }\n\n  findParent(id) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      function findParent(obj, id, callback) {\n        if (_this.count === 1) {\n          _this.count = 0;\n          callback('The parent node doesn\\'t exist.', null);\n        } else {\n          _this.count--;\n\n          if (typeof obj[_this.children] !== 'undefined') {\n            obj[_this.children].forEach(function (child) {\n              if (child[_this.id] === id) {\n                _this.count = 0;\n                callback(null, obj);\n              }\n            });\n\n            obj[_this.children].forEach(function (child) {\n              findParent(child, id, callback);\n            });\n          }\n        }\n      }\n\n      findParent(this.ds, id, (msg, parent) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(parent);\n        }\n      });\n    });\n  }\n\n  async findSiblings(id) {\n    const _this = this;\n\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    try {\n      const parent = await this.findParent(id);\n      return parent[this.children].filter(child => {\n        return child[_this.id] !== id;\n      });\n    } catch (err) {\n      throw new Error('The sibling nodes don\\'t exist.');\n    }\n  }\n\n  findAncestors(id) {\n    const _this = this;\n\n    return new Promise(async (resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      let nodes = [];\n\n      async function findAncestors(id) {\n        try {\n          if (id === _this.ds[_this.id]) {\n            if (!nodes.length) {\n              throw new Error('The ancestor nodes don\\'t exist.');\n            }\n\n            return nodes.slice(0);\n          } else {\n            const parent = await _this.findParent(id);\n            nodes.push(parent);\n            return findAncestors(parent[_this.id]);\n          }\n        } catch (err) {\n          throw new Error('The ancestor nodes don\\'t exist.');\n        }\n      }\n\n      try {\n        const ancestors = await findAncestors(id);\n        resolve(ancestors);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  } // validate the input parameters id and data(could be oject or array)\n\n\n  validateParams(id, data) {\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    if (!data || data.constructor !== Object && data.constructor !== Array || data.constructor === Object && !Object.keys(data).length || data.constructor === Array && !data.length || data.constructor === Array && data.length && !data.every(item => item && item.constructor === Object && Object.keys(item).length)) {\n      throw new Error('Parameter data is invalid.');\n    }\n  }\n\n  async addChildren(id, data) {\n    this.validateParams(id, data);\n\n    try {\n      const parent = await this.findNodeById(id);\n\n      if (data.constructor === Object) {\n        if (parent[this.children]) {\n          parent[this.children].push(data);\n        } else {\n          parent[this.children] = [data];\n        }\n      } else {\n        if (parent[this.children]) {\n          parent[this.children].push(...data);\n        } else {\n          parent[this.children] = data;\n        }\n      }\n    } catch (err) {\n      throw new Error('Failed to add child nodes.');\n    }\n  }\n\n  async addSiblings(id, data) {\n    this.validateParams(id, data);\n\n    try {\n      const parent = await this.findParent(id);\n\n      if (data.constructor === Object) {\n        parent[this.children].push(data);\n      } else {\n        parent[this.children].push(...data);\n      }\n    } catch (err) {\n      throw new Error('Failed to add sibling nodes.');\n    }\n  }\n\n  addRoot(data) {\n    const _this = this;\n\n    if (!data || data.constructor !== Object || data.constructor === Object && !Object.keys(data).length) {\n      throw new Error('Parameter data is invalid.');\n    }\n\n    try {\n      this.ds[this.children] = [Object.assign({}, this.ds)];\n      delete data[this.children];\n      Object.keys(this.ds).filter(prop => prop !== this.children).forEach(prop => {\n        if (!data[prop]) {\n          delete this.ds[prop];\n        }\n      });\n      Object.assign(this.ds, data);\n    } catch (err) {\n      throw new Error('Failed to add root node.');\n    }\n  }\n\n  async updateNode(data) {\n    if (!data || data.constructor !== Object || data.constructor === Object && !Object.keys(data).length || data.constructor === Object && Object.keys(data).length && !data[this.id]) {\n      throw new Error('Parameter data is invalid.');\n    }\n\n    try {\n      const node = await this.findNodeById(data[this.id]);\n      Object.assign(node, data);\n    } catch (err) {\n      throw new Error('Failed to update node.');\n    }\n  }\n\n  async updateNodes(ids, data) {\n    const _this = this;\n\n    if (!ids || ids.constructor === Array && !ids.length || !data) {\n      throw new Error('Input parameter is invalid.');\n    }\n\n    try {\n      for (const id of ids) {\n        data[_this.id] = id;\n        await this.updateNode(data);\n      }\n    } catch (err) {\n      throw err;\n    }\n  } // remove single node based on id\n\n\n  async removeNode(id) {\n    const _this = this;\n\n    if (id === this.ds[this.id]) {\n      throw new Error('Input parameter is invalid.');\n    }\n\n    const parent = await this.findParent(id);\n    const index = parent[this.children].map(node => node[_this.id]).indexOf(id);\n    parent[this.children].splice(index, 1);\n    this.count = 0;\n  } // param could be single id, id array or conditions object\n\n\n  async removeNodes(param) {\n    const _this = this;\n\n    if (!param || param.constructor === Array && !param.length || param.constructor === Object && !Object.keys(param).length) {\n      throw new Error('Input parameter is invalid.');\n    }\n\n    try {\n      // if passing in single id\n      if (param.constructor === String || param.constructor === Number) {\n        await this.removeNode(param);\n      } else if (param.constructor === Array) {\n        // if passing in id array\n        for (const p of param) {\n          await this.removeNode(p);\n        }\n      } else {\n        // if passing in conditions object\n        const nodes = await this.findNodes(param);\n        const ids = nodes.map(node => node[_this.id]);\n\n        for (const p of ids) {\n          await this.removeNode(p);\n        }\n      }\n    } catch (err) {\n      throw new Error('Failed to remove nodes.');\n    }\n  }\n\n}\n\nexports.default = JSONDigger;\n;","map":{"version":3,"sources":["../src/index.js"],"names":["constructor","countNodes","_this","Object","obj","child","findNodeById","reject","callback","node","resolve","matchConditions","flag","item","conditions","subitem","findChildren","parent","findNodes","nodes","findParent","findSiblings","findAncestors","id","ancestors","validateParams","data","addChildren","addSiblings","addRoot","prop","updateNode","updateNodes","ids","removeNode","index","removeNodes","param"],"mappings":"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","sourcesContent":["export default class JSONDigger {\n  constructor(datasource, idProp, childrenProp) {\n    this.ds = datasource;\n    this.id = idProp;\n    this.children = childrenProp;\n    this.count = 0;\n  }\n\n  countNodes (obj) {\n    var _this = this;\n    this.count++;\n    if (!obj || !Object.keys(obj).length) {\n      return false;\n    } else {\n      if (obj[this.children]) {\n        obj[this.children].forEach(child => {\n          _this.countNodes(child);\n        });\n      }\n    }\n  }\n\n  findNodeById (id) {\n    const _this = this;\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n      function findNodeById (obj, id, callback) {\n        if (!_this.count) {\n          return;\n        }\n        if (obj[_this.id] === id) {\n          _this.count = 0;\n          callback(null, obj);\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback('The node doesn\\'t exist.', null);\n          }\n          _this.count--;\n          if (obj[_this.children]) {\n            obj[_this.children].forEach(node => {\n              findNodeById(node, id, callback);\n            });\n          }\n        }\n      }\n      findNodeById(this.ds, id, (msg, node) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(node);\n        }\n      });\n    });\n  }\n\n  matchConditions (obj, conditions) {\n    var flag = true;\n    Object.keys(conditions).some(item => {\n      if (typeof conditions[item] === 'string' || typeof conditions[item] === 'number' || typeof conditions[item] === 'boolean') {\n        if (obj[item] !== conditions[item]) {\n          flag = false;\n          return true;\n        }\n      } else if (conditions[item] instanceof RegExp) {\n        if (!conditions[item].test(obj[item])) {\n          flag = false;\n          return true;\n        }\n      } else if (typeof conditions[item] === 'object') {\n        Object.keys(conditions[item]).some(subitem => {\n          switch (subitem) {\n            case '>': {\n              if (!(obj[item] > conditions[item][subitem])) {\n                flag = false;\n                return true;\n              }\n              break;\n            }\n            case '<': {\n              if (!(obj[item] < conditions[item][subitem])) {\n                flag = false;\n                return true;\n              }\n              break;\n            }\n            case '>=': {\n              if (!(obj[item] >= conditions[item][subitem])) {\n                flag = false;\n                return true;\n              }\n              break;\n            }\n            case '<=': {\n              if (!(obj[item] <= conditions[item][subitem])) {\n                flag = false;\n                return true;\n              }\n              break;\n            }\n            case '!==': {\n              if (!(obj[item] !== conditions[item][subitem])) {\n                flag = false;\n                return true;\n              }\n              break;\n            }\n          }\n        });\n        if (!flag) {\n          return false;\n        }\n      }\n    });\n\n    return flag;\n  }\n\n  async findChildren (id) {\n    const _this = this;\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n    try {\n      const parent = await this.findParent(id);\n      return parent[this.children];\n    } catch (err) {\n      throw new Error('The child nodes don\\'t exist.');\n    }\n  }\n\n  findNodes (conditions) {\n    const _this = this;\n    this.countNodes(this.ds);\n    return new Promise(async(resolve, reject) => {\n      if (!conditions || !Object.keys(conditions).length) {\n        return reject(new Error('Parameter conditions are invalid.'));\n      }\n      let nodes = [];\n      function findNodes(obj, conditions, callback) {\n        if (!_this.count) {\n          return;\n        }\n        if (_this.matchConditions(obj, conditions)) {\n          nodes.push(obj);\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n          }\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n          }\n        }\n        _this.count--;\n        if (obj[_this.children]) {\n          obj[_this.children].forEach(child => {\n            findNodes(child, conditions, callback);\n          });\n        }\n      }\n      findNodes(this.ds, conditions, (msg, nodes) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(nodes);\n        }\n      });\n    });\n  }\n\n  findParent (id) {\n    const _this = this;\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n      function findParent (obj, id, callback)  {\n        if (_this.count === 1) {\n          _this.count = 0;\n          callback('The parent node doesn\\'t exist.', null);\n        } else {\n          _this.count--;\n          if (typeof obj[_this.children] !== 'undefined') {\n            obj[_this.children].forEach(function(child) {\n              if (child[_this.id] === id) {\n                _this.count = 0;\n                callback(null, obj);\n              }\n            });\n            obj[_this.children].forEach(function(child) {\n              findParent(child, id, callback);\n            });\n          }\n        }\n      }\n      findParent(this.ds, id, (msg, parent) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(parent);\n        }\n      });\n    });\n  }\n\n  async findSiblings (id) {\n    const _this = this;\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n    try {\n      const parent = await this.findParent(id);\n      return parent[this.children].filter(child => {\n        return child[_this.id] !== id;\n      });\n    } catch (err) {\n      throw new Error('The sibling nodes don\\'t exist.');\n    }\n  }\n\n  findAncestors (id) {\n    const _this = this;\n    return new Promise(async(resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n      let  nodes = [];\n      async function findAncestors (id) {\n        try {\n          if (id === _this.ds[_this.id]) {\n            if (!nodes.length) {\n              throw new Error('The ancestor nodes don\\'t exist.');\n            }\n            return nodes.slice(0);\n          } else {\n            const parent = await _this.findParent(id);\n            nodes.push(parent);\n            return findAncestors(parent[_this.id]);\n          }\n        } catch (err) {\n          throw new Error('The ancestor nodes don\\'t exist.');\n        }\n      }\n      try {\n        const ancestors = await findAncestors(id);\n        resolve(ancestors);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n\n  // validate the input parameters id and data(could be oject or array)\n  validateParams(id, data) {\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n    if (!data\n      || (data.constructor !== Object && data.constructor !== Array)\n      || (data.constructor === Object && !Object.keys(data).length)\n      || (data.constructor === Array && !data.length)\n      || (data.constructor === Array && data.length && !data.every(item => item && item.constructor === Object && Object.keys(item).length))) {\n      throw new Error('Parameter data is invalid.');\n    }\n  }\n\n  async addChildren (id, data) {\n    this.validateParams(id, data);\n    try {\n      const parent = await this.findNodeById(id);\n      if (data.constructor === Object) {\n        if (parent[this.children]) {\n          parent[this.children].push(data);\n        } else {\n          parent[this.children] = [data];\n        }\n      } else {\n        if (parent[this.children]) {\n          parent[this.children].push(...data);\n        } else {\n          parent[this.children] = data;\n        }\n      }\n    } catch (err) {\n      throw new Error('Failed to add child nodes.');\n    }\n  }\n\n  async addSiblings (id, data) {\n    this.validateParams(id, data);\n    try {\n      const parent = await this.findParent(id);\n      if (data.constructor === Object) {\n        parent[this.children].push(data);\n      } else {\n        parent[this.children].push(...data);\n      }\n    } catch (err) {\n      throw new Error('Failed to add sibling nodes.');\n    }\n  }\n\n  addRoot (data) {\n    const _this = this;\n    if (!data || data.constructor !== Object || (data.constructor === Object && !Object.keys(data).length)) {\n      throw new Error('Parameter data is invalid.');\n    }\n    try {\n      this.ds[this.children] = [Object.assign({}, this.ds)];\n      delete data[this.children];\n      Object.keys(this.ds).filter(prop => prop !== this.children).forEach(prop => {\n        if (!data[prop]) {\n          delete this.ds[prop];\n        }\n      });\n      Object.assign(this.ds, data);\n    } catch (err) {\n      throw new Error('Failed to add root node.');\n    }\n  }\n\n  async updateNode (data) {\n    if (!data\n      || data.constructor !== Object\n      || (data.constructor === Object && !Object.keys(data).length)\n      || (data.constructor === Object && Object.keys(data).length && !data[this.id])) {\n      throw new Error('Parameter data is invalid.');\n    }\n    try {\n      const node = await this.findNodeById(data[this.id]);\n      Object.assign(node, data);\n    } catch (err) {\n      throw new Error('Failed to update node.');\n    }\n  }\n\n  async updateNodes (ids, data) {\n    const _this = this;\n    if (!ids\n      || (ids.constructor === Array && !ids.length)\n      || !data) {\n      throw new Error('Input parameter is invalid.');\n    }\n    try {\n      for (const id of ids) {\n        data[_this.id] = id; \n        await this.updateNode(data);\n      }\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  // remove single node based on id\n  async removeNode (id) {\n    const _this = this;\n    if (id === this.ds[this.id]) {\n      throw new Error('Input parameter is invalid.');\n    }\n    const parent = await this.findParent(id);\n    const index = parent[this.children].map(node => node[_this.id]).indexOf(id);\n    parent[this.children].splice(index, 1);\n    this.count = 0;\n  }\n\n  // param could be single id, id array or conditions object\n  async removeNodes (param) {\n    const _this = this;\n    if (!param\n      || (param.constructor === Array && !param.length)\n      || (param.constructor === Object && !Object.keys(param).length)) {\n      throw new Error('Input parameter is invalid.');\n    }\n    try {\n      // if passing in single id\n      if (param.constructor === String || param.constructor === Number) {\n        await this.removeNode(param);\n      } else if (param.constructor === Array) { // if passing in id array\n        for (const p of param) {\n          await this.removeNode(p);\n        }\n      } else { // if passing in conditions object\n        const nodes = await this.findNodes(param);\n        const ids = nodes.map(node => node[_this.id]);\n        for (const p of ids) {\n          await this.removeNode(p);\n        }\n      }\n    } catch (err) {\n      throw new Error('Failed to remove nodes.');\n    }\n  }\n\n};"]},"metadata":{},"sourceType":"script"}