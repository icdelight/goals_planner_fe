(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReduxPersist = {}));
}(this, (function (exports) { 'use strict';

  var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
  var redefine = require('../internals/redefine');
  var toString = require('../internals/object-to-string');

  // `Object.prototype.toString` method
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (!TO_STRING_TAG_SUPPORT) {
    redefine(Object.prototype, 'toString', toString, { unsafe: true });
  }

  var $ = require('../internals/export');
  var IS_PURE = require('../internals/is-pure');
  var global$1 = require('../internals/global');
  var getBuiltIn = require('../internals/get-built-in');
  var NativePromise = require('../internals/native-promise-constructor');
  var redefine$1 = require('../internals/redefine');
  var redefineAll = require('../internals/redefine-all');
  var setToStringTag = require('../internals/set-to-string-tag');
  var setSpecies = require('../internals/set-species');
  var isObject = require('../internals/is-object');
  var aFunction = require('../internals/a-function');
  var anInstance = require('../internals/an-instance');
  var inspectSource = require('../internals/inspect-source');
  var iterate = require('../internals/iterate');
  var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
  var speciesConstructor = require('../internals/species-constructor');
  var task = require('../internals/task').set;
  var microtask = require('../internals/microtask');
  var promiseResolve = require('../internals/promise-resolve');
  var hostReportErrors = require('../internals/host-report-errors');
  var newPromiseCapabilityModule = require('../internals/new-promise-capability');
  var perform = require('../internals/perform');
  var InternalStateModule = require('../internals/internal-state');
  var isForced = require('../internals/is-forced');
  var wellKnownSymbol = require('../internals/well-known-symbol');
  var IS_NODE = require('../internals/engine-is-node');
  var V8_VERSION = require('../internals/engine-v8-version');

  var SPECIES = wellKnownSymbol('species');
  var PROMISE = 'Promise';
  var getInternalState = InternalStateModule.get;
  var setInternalState = InternalStateModule.set;
  var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
  var PromiseConstructor = NativePromise;
  var TypeError$1 = global$1.TypeError;
  var document = global$1.document;
  var process = global$1.process;
  var $fetch = getBuiltIn('fetch');
  var newPromiseCapability = newPromiseCapabilityModule.f;
  var newGenericPromiseCapability = newPromiseCapability;
  var DISPATCH_EVENT = !!(document && document.createEvent && global$1.dispatchEvent);
  var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

  var FORCED = isForced(PROMISE, function () {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE) {
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (V8_VERSION === 66) return true;
      // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true;
    }
    // We need Promise#finally in the pure version for preventing prototype pollution
    if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = PromiseConstructor.resolve(1);
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
  });

  var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
  });

  // helpers
  var isThenable = function (it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify = function (state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function () {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0;
      // variable length - can't use forEach
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(state);
              state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value); // can throw
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(state);
    });
  };

  var dispatchEvent = function (name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$1.dispatchEvent(event);
    } else event = { promise: promise, reason: reason };
    if (!NATIVE_REJECTION_EVENT && (handler = global$1['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function (state) {
    task.call(global$1, function () {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE) {
            process.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function (state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function (state) {
    task.call(global$1, function () {
      var promise = state.facade;
      if (IS_NODE) {
        process.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function (fn, state, unwrap) {
    return function (value) {
      fn(state, value, unwrap);
    };
  };

  var internalReject = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
  };

  var internalResolve = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function () {
          var wrapper = { done: false };
          try {
            then.call(value,
              bind(internalResolve, wrapper, state),
              bind(internalReject, wrapper, state)
            );
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };

  // constructor polyfill
  if (FORCED) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromiseConstructor, PROMISE);
      aFunction(executor);
      Internal.call(this);
      var state = getInternalState(this);
      try {
        executor(bind(internalResolve, state), bind(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
      setInternalState(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };
    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.es/ecma262/#sec-promise.prototype.then
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = IS_NODE ? process.domain : undefined;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify(state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.es/ecma262/#sec-promise.prototype.catch
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      var state = getInternalState(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, state);
      this.reject = bind(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
      return C === PromiseConstructor || C === PromiseWrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };

    if (!IS_PURE && typeof NativePromise == 'function') {
      nativeThen = NativePromise.prototype.then;

      // wrap native Promise#then for native async functions
      redefine$1(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          nativeThen.call(that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });

      // wrap fetch result
      if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch(input /* , init */) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global$1, arguments));
        }
      });
    }
  }

  $({ global: true, wrap: true, forced: FORCED }, {
    Promise: PromiseConstructor
  });

  setToStringTag(PromiseConstructor, PROMISE, false, true);
  setSpecies(PROMISE);

  PromiseWrapper = getBuiltIn(PROMISE);

  // statics
  $({ target: PROMISE, stat: true, forced: FORCED }, {
    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      capability.reject.call(undefined, r);
      return capability.promise;
    }
  });

  $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
    }
  });

  $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          $promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction(C.resolve);
        iterate(iterable, function (promise) {
          $promiseResolve.call(C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var $$1 = require('../internals/export');
  var global$2 = require('../internals/global');
  var userAgent = require('../internals/engine-user-agent');

  var slice = [].slice;
  var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

  var wrap = function (scheduler) {
    return function (handler, timeout /* , ...arguments */) {
      var boundArgs = arguments.length > 2;
      var args = boundArgs ? slice.call(arguments, 2) : undefined;
      return scheduler(boundArgs ? function () {
        // eslint-disable-next-line no-new-func
        (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
      } : handler, timeout);
    };
  };

  // ie9- setTimeout & setInterval additional parameters fix
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
  $$1({ global: true, bind: true, forced: MSIE }, {
    // `setTimeout` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
    setTimeout: wrap(global$2.setTimeout),
    // `setInterval` method
    // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
    setInterval: wrap(global$2.setInterval)
  });

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var KEY_PREFIX = 'persist:';
  var FLUSH = 'persist/FLUSH';
  var REHYDRATE = 'persist/REHYDRATE';
  var PAUSE = 'persist/PAUSE';
  var PERSIST = 'persist/PERSIST';
  var PURGE = 'persist/PURGE';
  var REGISTER = 'persist/REGISTER';
  var DEFAULT_VERSION = -1;

  var $$2 = require('../internals/export');
  var forEach = require('../internals/array-for-each');

  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  $$2({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
    forEach: forEach
  });

  var $$3 = require('../internals/export');
  var IndexedObject = require('../internals/indexed-object');
  var toIndexedObject = require('../internals/to-indexed-object');
  var arrayMethodIsStrict = require('../internals/array-method-is-strict');

  var nativeJoin = [].join;

  var ES3_STRINGS = IndexedObject != Object;
  var STRICT_METHOD = arrayMethodIsStrict('join', ',');

  // `Array.prototype.join` method
  // https://tc39.es/ecma262/#sec-array.prototype.join
  $$3({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
    join: function join(separator) {
      return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
  });

  var $$4 = require('../internals/export');
  var toObject = require('../internals/to-object');
  var nativeKeys = require('../internals/object-keys');
  var fails = require('../internals/fails');

  var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  $$4({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
    keys: function keys(it) {
      return nativeKeys(toObject(it));
    }
  });

  var global$3 = require('../internals/global');
  var DOMIterables = require('../internals/dom-iterables');
  var forEach$1 = require('../internals/array-for-each');
  var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

  for (var COLLECTION_NAME in DOMIterables) {
    var Collection = global$3[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype && CollectionPrototype.forEach !== forEach$1) try {
      createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach$1);
    } catch (error) {
      CollectionPrototype.forEach = forEach$1;
    }
  }

  /*
    autoMergeLevel1: 
      - merges 1 level of substate
      - skips substate if already modified
  */
  function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
    var debug = _ref.debug;

    var newState = _objectSpread2({}, reducedState); // only rehydrate if inboundState exists and is an object


    if (inboundState && _typeof(inboundState) === 'object') {
      Object.keys(inboundState).forEach(function (key) {
        // ignore _persist data
        if (key === '_persist') return; // if reducer modifies substate, skip auto rehydration

        if (originalState[key] !== reducedState[key]) {
          if ( debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);
          return;
        } // otherwise hard set the new value


        newState[key] = inboundState[key];
      });
    }

    if ( debug && inboundState && _typeof(inboundState) === 'object') console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(', '), "'"));
    return newState;
  }

  var $$5 = require('../internals/export');
  var fails$1 = require('../internals/fails');
  var isArray = require('../internals/is-array');
  var isObject$1 = require('../internals/is-object');
  var toObject$1 = require('../internals/to-object');
  var toLength = require('../internals/to-length');
  var createProperty = require('../internals/create-property');
  var arraySpeciesCreate = require('../internals/array-species-create');
  var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
  var wellKnownSymbol$1 = require('../internals/well-known-symbol');
  var V8_VERSION$1 = require('../internals/engine-v8-version');

  var IS_CONCAT_SPREADABLE = wellKnownSymbol$1('isConcatSpreadable');
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679
  var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$1 >= 51 || !fails$1(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });

  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

  var isConcatSpreadable = function (O) {
    if (!isObject$1(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
  };

  var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

  // `Array.prototype.concat` method
  // https://tc39.es/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species
  $$5({ target: 'Array', proto: true, forced: FORCED$1 }, {
    concat: function concat(arg) { // eslint-disable-line no-unused-vars
      var O = toObject$1(this);
      var A = arraySpeciesCreate(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = toLength(E.length);
          if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
        } else {
          if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });

  var $$6 = require('../internals/export');
  var $indexOf = require('../internals/array-includes').indexOf;
  var arrayMethodIsStrict$1 = require('../internals/array-method-is-strict');
  var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

  var nativeIndexOf = [].indexOf;

  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
  var STRICT_METHOD$1 = arrayMethodIsStrict$1('indexOf');
  var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  $$6({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH }, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
      return NEGATIVE_ZERO
        // convert -0 to +0
        ? nativeIndexOf.apply(this, arguments) || 0
        : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $$7 = require('../internals/export');
  var $reduce = require('../internals/array-reduce').left;
  var arrayMethodIsStrict$2 = require('../internals/array-method-is-strict');
  var arrayMethodUsesToLength$1 = require('../internals/array-method-uses-to-length');
  var CHROME_VERSION = require('../internals/engine-v8-version');
  var IS_NODE$1 = require('../internals/engine-is-node');

  var STRICT_METHOD$2 = arrayMethodIsStrict$2('reduce');
  var USES_TO_LENGTH$1 = arrayMethodUsesToLength$1('reduce', { 1: 0 });
  // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  var CHROME_BUG = !IS_NODE$1 && CHROME_VERSION > 79 && CHROME_VERSION < 83;

  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  $$7({ target: 'Array', proto: true, forced: !STRICT_METHOD$2 || !USES_TO_LENGTH$1 || CHROME_BUG }, {
    reduce: function reduce(callbackfn /* , initialValue */) {
      return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // @TODO remove once flow < 0.63 support is no longer required.
  function createPersistoid(config) {
    // defaults
    var blacklist = config.blacklist || null;
    var whitelist = config.whitelist || null;
    var transforms = config.transforms || [];
    var throttle = config.throttle || 0;
    var storageKey = "".concat(config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX).concat(config.key);
    var storage = config.storage;
    var serialize;

    if (config.serialize === false) {
      serialize = function serialize(x) {
        return x;
      };
    } else if (typeof config.serialize === 'function') {
      serialize = config.serialize;
    } else {
      serialize = defaultSerialize;
    }

    var writeFailHandler = config.writeFailHandler || null; // initialize stateful values

    var lastState = {};
    var stagedState = {};
    var keysToProcess = [];
    var timeIterator = null;
    var writePromise = null;

    var update = function update(state) {
      // add any changed keys to the queue
      Object.keys(state).forEach(function (key) {
        if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop

        if (lastState[key] === state[key]) return; // value unchanged? noop

        if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop

        keysToProcess.push(key); // add key to queue
      }); //if any key is missing in the new state which was present in the lastState,
      //add it for processing too

      Object.keys(lastState).forEach(function (key) {
        if (state[key] === undefined && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== undefined) {
          keysToProcess.push(key);
        }
      }); // start the time iterator if not running (read: throttle)

      if (timeIterator === null) {
        timeIterator = setInterval(processNextKey, throttle);
      }

      lastState = state;
    };

    function processNextKey() {
      if (keysToProcess.length === 0) {
        if (timeIterator) clearInterval(timeIterator);
        timeIterator = null;
        return;
      }

      var key = keysToProcess.shift();
      var endState = transforms.reduce(function (subState, transformer) {
        return transformer["in"](subState, key, lastState);
      }, lastState[key]);

      if (endState !== undefined) {
        try {
          stagedState[key] = serialize(endState);
        } catch (err) {
          console.error('redux-persist/createPersistoid: error serializing state', err);
        }
      } else {
        //if the endState is undefined, no need to persist the existing serialized content
        delete stagedState[key];
      }

      if (keysToProcess.length === 0) {
        writeStagedState();
      }
    }

    function writeStagedState() {
      // cleanup any removed keys just before write.
      Object.keys(stagedState).forEach(function (key) {
        if (lastState[key] === undefined) {
          delete stagedState[key];
        }
      });
      writePromise = storage.setItem(storageKey, serialize(stagedState))["catch"](onWriteFail);
    }

    function passWhitelistBlacklist(key) {
      if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false;
      if (blacklist && blacklist.indexOf(key) !== -1) return false;
      return true;
    }

    function onWriteFail(err) {
      // @TODO add fail handlers (typically storage full)
      if (writeFailHandler) writeFailHandler(err);

      if (err && "development" !== 'production') {
        console.error('Error storing data', err);
      }
    }

    var flush = function flush() {
      while (keysToProcess.length !== 0) {
        processNextKey();
      }

      return writePromise || Promise.resolve();
    }; // return `persistoid`


    return {
      update: update,
      flush: flush
    };
  } // @NOTE in the future this may be exposed via config

  function defaultSerialize(data) {
    return JSON.stringify(data);
  }

  var $$8 = require('../internals/export');
  var $reduceRight = require('../internals/array-reduce').right;
  var arrayMethodIsStrict$3 = require('../internals/array-method-is-strict');
  var arrayMethodUsesToLength$2 = require('../internals/array-method-uses-to-length');
  var CHROME_VERSION$1 = require('../internals/engine-v8-version');
  var IS_NODE$2 = require('../internals/engine-is-node');

  var STRICT_METHOD$3 = arrayMethodIsStrict$3('reduceRight');
  // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
  var USES_TO_LENGTH$2 = arrayMethodUsesToLength$2('reduce', { 1: 0 });
  // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  var CHROME_BUG$1 = !IS_NODE$2 && CHROME_VERSION$1 > 79 && CHROME_VERSION$1 < 83;

  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  $$8({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 || !USES_TO_LENGTH$2 || CHROME_BUG$1 }, {
    reduceRight: function reduceRight(callbackfn /* , initialValue */) {
      return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  function getStoredState(config) {
    var transforms = config.transforms || [];
    var storageKey = "".concat(config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX).concat(config.key);
    var storage = config.storage;
    var debug = config.debug;
    var deserialize;

    if (config.deserialize === false) {
      deserialize = function deserialize(x) {
        return x;
      };
    } else if (typeof config.deserialize === 'function') {
      deserialize = config.deserialize;
    } else {
      deserialize = defaultDeserialize;
    }

    return storage.getItem(storageKey).then(function (serialized) {
      if (!serialized) return undefined;else {
        try {
          var state = {};
          var rawState = deserialize(serialized);
          Object.keys(rawState).forEach(function (key) {
            state[key] = transforms.reduceRight(function (subState, transformer) {
              return transformer.out(subState, key, rawState);
            }, deserialize(rawState[key]));
          });
          return state;
        } catch (err) {
          if ( debug) console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err);
          throw err;
        }
      }
    });
  }

  function defaultDeserialize(serial) {
    return JSON.parse(serial);
  }

  function purgeStoredState(config) {
    var storage = config.storage;
    var storageKey = "".concat(config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX).concat(config.key);
    return storage.removeItem(storageKey, warnIfRemoveError);
  }

  function warnIfRemoveError(err) {
    if (err && "development" !== 'production') {
      console.error('redux-persist/purgeStoredState: Error purging data stored state', err);
    }
  }

  var DEFAULT_TIMEOUT = 5000;
  /*
    @TODO add validation / handling for:
    - persisting a reducer which has nested _persist
    - handling actions that fire before reydrate is called
  */

  function persistReducer(config, baseReducer) {
    {
      if (!config) throw new Error('config is required for persistReducer');
      if (!config.key) throw new Error('key is required in persistor config');
      if (!config.storage) throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
    }

    var version = config.version !== undefined ? config.version : DEFAULT_VERSION;
    var debug = config.debug || false;
    var stateReconciler = config.stateReconciler === undefined ? autoMergeLevel1 : config.stateReconciler;
    var getStoredState$1 = config.getStoredState || getStoredState;
    var timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;
    var _persistoid = null;
    var _purge = false;
    var _paused = true;

    var conditionalUpdate = function conditionalUpdate(state) {
      // update the persistoid only if we are rehydrated and not paused
      state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
      return state;
    };

    return function (state, action) {
      var _ref = state || {},
          _persist = _ref._persist,
          rest = _objectWithoutProperties(_ref, ["_persist"]); // $FlowIgnore need to update State type


      var restState = rest;

      if (action.type === PERSIST) {
        var _sealed = false;

        var _rehydrate = function _rehydrate(payload, err) {
          // dev warning if we are already sealed
          if ( _sealed) console.error("redux-persist: rehydrate for \"".concat(config.key, "\" called after timeout."), payload, err); // only rehydrate if we are not already sealed

          if (!_sealed) {
            action.rehydrate(config.key, payload, err);
            _sealed = true;
          }
        };

        timeout && setTimeout(function () {
          !_sealed && _rehydrate(undefined, new Error("redux-persist: persist timed out for persist key \"".concat(config.key, "\"")));
        }, timeout); // @NOTE PERSIST resumes if paused.

        _paused = false; // @NOTE only ever create persistoid once, ensure we call it at least once, even if _persist has already been set

        if (!_persistoid) _persistoid = createPersistoid(config); // @NOTE PERSIST can be called multiple times, noop after the first

        if (_persist) {
          // We still need to call the base reducer because there might be nested
          // uses of persistReducer which need to be aware of the PERSIST action
          return _objectSpread2(_objectSpread2({}, baseReducer(restState, action)), {}, {
            _persist: _persist
          });
        }

        if (typeof action.rehydrate !== 'function' || typeof action.register !== 'function') throw new Error('redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.');
        action.register(config.key);
        getStoredState$1(config).then(function (restoredState) {
          var migrate = config.migrate || function (s, v) {
            return Promise.resolve(s);
          };

          migrate(restoredState, version).then(function (migratedState) {
            _rehydrate(migratedState);
          }, function (migrateErr) {
            if ( migrateErr) console.error('redux-persist: migration error', migrateErr);

            _rehydrate(undefined, migrateErr);
          });
        }, function (err) {
          _rehydrate(undefined, err);
        });
        return _objectSpread2(_objectSpread2({}, baseReducer(restState, action)), {}, {
          _persist: {
            version: version,
            rehydrated: false
          }
        });
      } else if (action.type === PURGE) {
        _purge = true;
        action.result(purgeStoredState(config));
        return _objectSpread2(_objectSpread2({}, baseReducer(restState, action)), {}, {
          _persist: _persist
        });
      } else if (action.type === FLUSH) {
        action.result(_persistoid && _persistoid.flush());
        return _objectSpread2(_objectSpread2({}, baseReducer(restState, action)), {}, {
          _persist: _persist
        });
      } else if (action.type === PAUSE) {
        _paused = true;
      } else if (action.type === REHYDRATE) {
        // noop on restState if purging
        if (_purge) return _objectSpread2(_objectSpread2({}, restState), {}, {
          _persist: _objectSpread2(_objectSpread2({}, _persist), {}, {
            rehydrated: true
          })
        }); // @NOTE if key does not match, will continue to default else below

        if (action.key === config.key) {
          var reducedState = baseReducer(restState, action);
          var inboundState = action.payload; // only reconcile state if stateReconciler and inboundState are both defined

          var reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;

          var _newState = _objectSpread2(_objectSpread2({}, reconciledRest), {}, {
            _persist: _objectSpread2(_objectSpread2({}, _persist), {}, {
              rehydrated: true
            })
          });

          return conditionalUpdate(_newState);
        }
      } // if we have not already handled PERSIST, straight passthrough


      if (!_persist) return baseReducer(state, action); // run base reducer:
      // is state modified ? return original : return updated

      var newState = baseReducer(restState, action);
      if (newState === restState) return state;
      return conditionalUpdate(_objectSpread2(_objectSpread2({}, newState), {}, {
        _persist: _persist
      }));
    };
  }

  function symbolObservablePonyfill(root) {
  	var result;
  	var Symbol = root.Symbol;

  	if (typeof Symbol === 'function') {
  		if (Symbol.observable) {
  			result = Symbol.observable;
  		} else {
  			result = Symbol('observable');
  			Symbol.observable = result;
  		}
  	} else {
  		result = '@@observable';
  	}

  	return result;
  }

  /* global window */

  var root;

  if (typeof self !== 'undefined') {
    root = self;
  } else if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof module !== 'undefined') {
    root = module;
  } else {
    root = Function('return this')();
  }

  var result = symbolObservablePonyfill(root);

  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */
  var randomString = function randomString() {
    return Math.random().toString(36).substring(7).split('').join('.');
  };

  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };

  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */
  function isPlainObject(obj) {
    if (typeof obj !== 'object' || obj === null) return false;
    var proto = obj;

    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(obj) === proto;
  }

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */

  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
      throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
    }

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }

      return enhancer(createStore)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    /**
     * This makes a shallow copy of currentListeners so we can use
     * nextListeners as a temporary list while dispatching.
     *
     * This prevents any bugs around consumers calling
     * subscribe/unsubscribe in the middle of a dispatch.
     */

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */


    function getState() {
      if (isDispatching) {
        throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
      }

      return currentState;
    }
    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */


    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected the listener to be a function.');
      }

      if (isDispatching) {
        throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
      }

      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        if (isDispatching) {
          throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
        }

        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
        currentListeners = null;
      };
    }
    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */


    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;

      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }
    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */


    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }

      currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
      // Any reducers that existed in both the new and old rootReducer
      // will receive the previous state. This effectively populates
      // the new state tree with any relevant data from the old one.

      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */


    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            throw new TypeError('Expected the observer to be an object.');
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe
          };
        }
      }, _ref[result] = function () {
        return this;
      }, _ref;
    } // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.


    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[result] = observable, _ref2;
  }

  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */
  function warning(message) {
    /* eslint-disable no-console */
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    /* eslint-enable no-console */


    try {
      // This error was thrown as a convenience so that if you enable
      // "break on all exceptions" in your console,
      // it would pause the execution at this line.
      throw new Error(message);
    } catch (e) {} // eslint-disable-line no-empty

  }

  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
    return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
  }

  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }

    if (!isPlainObject(inputState)) {
      return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
    }

    var unexpectedKeys = Object.keys(inputState).filter(function (key) {
      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });
    unexpectedKeys.forEach(function (key) {
      unexpectedKeyCache[key] = true;
    });
    if (action && action.type === ActionTypes.REPLACE) return;

    if (unexpectedKeys.length > 0) {
      return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
    }
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {
        type: ActionTypes.INIT
      });

      if (typeof initialState === 'undefined') {
        throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
      }

      if (typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined') {
        throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
      }
    });
  }
  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */


  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      {
        if (typeof reducers[key] === 'undefined') {
          warning("No reducer provided for key \"" + key + "\"");
        }
      }

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }

    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
    // keys multiple times.

    var unexpectedKeyCache;

    {
      unexpectedKeyCache = {};
    }

    var shapeAssertionError;

    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

        if (warningMessage) {
          warning(warningMessage);
        }
      }

      var hasChanged = false;
      var nextState = {};

      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);

        if (typeof nextStateForKey === 'undefined') {
          var errorMessage = getUndefinedStateErrorMessage(_key, action);
          throw new Error(errorMessage);
        }

        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }

      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }

  /*
   * This is a dummy function to check if the function name has been altered by minification.
   * If the function has been minified and NODE_ENV !== 'production', warn the user.
   */

  function isCrushed() {}

  if ( typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
  }

  var $$9 = require('../internals/export');
  var isArray$1 = require('../internals/is-array');

  // `Array.isArray` method
  // https://tc39.es/ecma262/#sec-array.isarray
  $$9({ target: 'Array', stat: true }, {
    isArray: isArray$1
  });

  /*
    autoMergeLevel2: 
      - merges 2 level of substate
      - skips substate if already modified
      - this is essentially redux-perist v4 behavior
  */
  function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {
    var debug = _ref.debug;

    var newState = _objectSpread2({}, reducedState); // only rehydrate if inboundState exists and is an object


    if (inboundState && _typeof(inboundState) === 'object') {
      Object.keys(inboundState).forEach(function (key) {
        // ignore _persist data
        if (key === '_persist') return; // if reducer modifies substate, skip auto rehydration

        if (originalState[key] !== reducedState[key]) {
          if ( debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);
          return;
        }

        if (isPlainEnoughObject(reducedState[key])) {
          // if object is plain enough shallow merge the new values (hence "Level2")
          newState[key] = _objectSpread2(_objectSpread2({}, newState[key]), inboundState[key]);
          return;
        } // otherwise hard set


        newState[key] = inboundState[key];
      });
    }

    if ( debug && inboundState && _typeof(inboundState) === 'object') console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(', '), "'"));
    return newState;
  }

  function isPlainEnoughObject(o) {
    return o !== null && !Array.isArray(o) && _typeof(o) === 'object';
  }

  // combineReducers + persistReducer with stateReconciler defaulted to autoMergeLevel2
  function persistCombineReducers(config, reducers) {
    config.stateReconciler = config.stateReconciler === undefined ? autoMergeLevel2 : config.stateReconciler;
    return persistReducer(config, combineReducers(reducers));
  }

  var toIndexedObject$1 = require('../internals/to-indexed-object');
  var addToUnscopables = require('../internals/add-to-unscopables');
  var Iterators = require('../internals/iterators');
  var InternalStateModule$1 = require('../internals/internal-state');
  var defineIterator = require('../internals/define-iterator');

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$1 = InternalStateModule$1.set;
  var getInternalState$1 = InternalStateModule$1.getterFor(ARRAY_ITERATOR);

  // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator
  module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState$1(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject$1(iterated), // target
      index: 0,                          // next index
      kind: kind                         // kind
    });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = undefined;
      return { value: undefined, done: true };
    }
    if (kind == 'keys') return { value: index, done: false };
    if (kind == 'values') return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject
  Iterators.Arguments = Iterators.Array;

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  var $$a = require('../internals/export');
  var toAbsoluteIndex = require('../internals/to-absolute-index');
  var toInteger = require('../internals/to-integer');
  var toLength$1 = require('../internals/to-length');
  var toObject$2 = require('../internals/to-object');
  var arraySpeciesCreate$1 = require('../internals/array-species-create');
  var createProperty$1 = require('../internals/create-property');
  var arrayMethodHasSpeciesSupport$1 = require('../internals/array-method-has-species-support');
  var arrayMethodUsesToLength$3 = require('../internals/array-method-uses-to-length');

  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$1('splice');
  var USES_TO_LENGTH$3 = arrayMethodUsesToLength$3('splice', { ACCESSORS: true, 0: 0, 1: 2 });

  var max = Math.max;
  var min = Math.min;
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

  // `Array.prototype.splice` method
  // https://tc39.es/ecma262/#sec-array.prototype.splice
  // with adding support of @@species
  $$a({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$3 }, {
    splice: function splice(start, deleteCount /* , ...items */) {
      var O = toObject$2(this);
      var len = toLength$1(O.length);
      var actualStart = toAbsoluteIndex(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;
      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
      }
      if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
        throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }
      A = arraySpeciesCreate$1(O, actualDeleteCount);
      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty$1(A, k, O[from]);
      }
      A.length = actualDeleteCount;
      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
        for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
      }
      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }
      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  var charAt = require('../internals/string-multibyte').charAt;
  var InternalStateModule$2 = require('../internals/internal-state');
  var defineIterator$1 = require('../internals/define-iterator');

  var STRING_ITERATOR = 'String Iterator';
  var setInternalState$2 = InternalStateModule$2.set;
  var getInternalState$2 = InternalStateModule$2.getterFor(STRING_ITERATOR);

  // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
  defineIterator$1(String, 'String', function (iterated) {
    setInternalState$2(this, {
      type: STRING_ITERATOR,
      string: String(iterated),
      index: 0
    });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState$2(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return { value: undefined, done: true };
    point = charAt(string, index);
    state.index += point.length;
    return { value: point, done: false };
  });

  var global$4 = require('../internals/global');
  var DOMIterables$1 = require('../internals/dom-iterables');
  var ArrayIteratorMethods = require('../modules/es.array.iterator');
  var createNonEnumerableProperty$1 = require('../internals/create-non-enumerable-property');
  var wellKnownSymbol$2 = require('../internals/well-known-symbol');

  var ITERATOR = wellKnownSymbol$2('iterator');
  var TO_STRING_TAG = wellKnownSymbol$2('toStringTag');
  var ArrayValues = ArrayIteratorMethods.values;

  for (var COLLECTION_NAME$1 in DOMIterables$1) {
    var Collection$1 = global$4[COLLECTION_NAME$1];
    var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
    if (CollectionPrototype$1) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype$1[ITERATOR] !== ArrayValues) try {
        createNonEnumerableProperty$1(CollectionPrototype$1, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype$1[ITERATOR] = ArrayValues;
      }
      if (!CollectionPrototype$1[TO_STRING_TAG]) {
        createNonEnumerableProperty$1(CollectionPrototype$1, TO_STRING_TAG, COLLECTION_NAME$1);
      }
      if (DOMIterables$1[COLLECTION_NAME$1]) for (var METHOD_NAME in ArrayIteratorMethods) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype$1[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
          createNonEnumerableProperty$1(CollectionPrototype$1, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype$1[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
        }
      }
    }
  }

  var initialState = {
    registry: [],
    bootstrapped: false
  };

  var persistorReducer = function persistorReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case REGISTER:
        return _objectSpread2(_objectSpread2({}, state), {}, {
          registry: [].concat(_toConsumableArray(state.registry), [action.key])
        });

      case REHYDRATE:
        var firstIndex = state.registry.indexOf(action.key);

        var registry = _toConsumableArray(state.registry);

        registry.splice(firstIndex, 1);
        return _objectSpread2(_objectSpread2({}, state), {}, {
          registry: registry,
          bootstrapped: registry.length === 0
        });

      default:
        return state;
    }
  };

  function persistStore(store, options, cb) {
    // help catch incorrect usage of passing PersistConfig in as PersistorOptions
    {
      var optionsToTest = options || {};
      var bannedKeys = ['blacklist', 'whitelist', 'transforms', 'storage', 'keyPrefix', 'migrate'];
      bannedKeys.forEach(function (k) {
        if (!!optionsToTest[k]) console.error("redux-persist: invalid option passed to persistStore: \"".concat(k, "\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer."));
      });
    }

    var boostrappedCb = cb || false;

    var _pStore = createStore(persistorReducer, initialState, options && options.enhancer ? options.enhancer : undefined);

    var register = function register(key) {
      _pStore.dispatch({
        type: REGISTER,
        key: key
      });
    };

    var rehydrate = function rehydrate(key, payload, err) {
      var rehydrateAction = {
        type: REHYDRATE,
        payload: payload,
        err: err,
        key: key
      }; // dispatch to `store` to rehydrate and `persistor` to track result

      store.dispatch(rehydrateAction);

      _pStore.dispatch(rehydrateAction);

      if (boostrappedCb && persistor.getState().bootstrapped) {
        boostrappedCb();
        boostrappedCb = false;
      }
    };

    var persistor = _objectSpread2(_objectSpread2({}, _pStore), {}, {
      purge: function purge() {
        var results = [];
        store.dispatch({
          type: PURGE,
          result: function result(purgeResult) {
            results.push(purgeResult);
          }
        });
        return Promise.all(results);
      },
      flush: function flush() {
        var results = [];
        store.dispatch({
          type: FLUSH,
          result: function result(flushResult) {
            results.push(flushResult);
          }
        });
        return Promise.all(results);
      },
      pause: function pause() {
        store.dispatch({
          type: PAUSE
        });
      },
      persist: function persist() {
        store.dispatch({
          type: PERSIST,
          register: register,
          rehydrate: rehydrate
        });
      }
    });

    if (!(options && options.manualPersist)) {
      persistor.persist();
    }

    return persistor;
  }

  var $$b = require('../internals/export');
  var $filter = require('../internals/array-iteration').filter;
  var arrayMethodHasSpeciesSupport$2 = require('../internals/array-method-has-species-support');
  var arrayMethodUsesToLength$4 = require('../internals/array-method-uses-to-length');

  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$2('filter');
  // Edge 14- issue
  var USES_TO_LENGTH$4 = arrayMethodUsesToLength$4('filter');

  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  // with adding support of @@species
  $$b({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$4 }, {
    filter: function filter(callbackfn /* , thisArg */) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $$c = require('../internals/export');
  var $map = require('../internals/array-iteration').map;
  var arrayMethodHasSpeciesSupport$3 = require('../internals/array-method-has-species-support');
  var arrayMethodUsesToLength$5 = require('../internals/array-method-uses-to-length');

  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3('map');
  // FF49- issue
  var USES_TO_LENGTH$5 = arrayMethodUsesToLength$5('map');

  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  // with adding support of @@species
  $$c({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$5 }, {
    map: function map(callbackfn /* , thisArg */) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $$d = require('../internals/export');
  var aFunction$1 = require('../internals/a-function');
  var toObject$3 = require('../internals/to-object');
  var fails$2 = require('../internals/fails');
  var arrayMethodIsStrict$4 = require('../internals/array-method-is-strict');

  var test = [];
  var nativeSort = test.sort;

  // IE8-
  var FAILS_ON_UNDEFINED = fails$2(function () {
    test.sort(undefined);
  });
  // V8 bug
  var FAILS_ON_NULL = fails$2(function () {
    test.sort(null);
  });
  // Old WebKit
  var STRICT_METHOD$4 = arrayMethodIsStrict$4('sort');

  var FORCED$2 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$4;

  // `Array.prototype.sort` method
  // https://tc39.es/ecma262/#sec-array.prototype.sort
  $$d({ target: 'Array', proto: true, forced: FORCED$2 }, {
    sort: function sort(comparefn) {
      return comparefn === undefined
        ? nativeSort.call(toObject$3(this))
        : nativeSort.call(toObject$3(this), aFunction$1(comparefn));
    }
  });

  var $$e = require('../internals/export');
  var parseIntImplementation = require('../internals/number-parse-int');

  // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix
  $$e({ global: true, forced: parseInt != parseIntImplementation }, {
    parseInt: parseIntImplementation
  });

  function createMigrate(migrations, config) {
    var _ref = config || {},
        debug = _ref.debug;

    return function (state, currentVersion) {
      if (!state) {
        if ( debug) console.log('redux-persist: no inbound state, skipping migration');
        return Promise.resolve(undefined);
      }

      var inboundVersion = state._persist && state._persist.version !== undefined ? state._persist.version : DEFAULT_VERSION;

      if (inboundVersion === currentVersion) {
        if ( debug) console.log('redux-persist: versions match, noop migration');
        return Promise.resolve(state);
      }

      if (inboundVersion > currentVersion) {
        console.error('redux-persist: downgrading version is not supported');
        return Promise.resolve(state);
      }

      var migrationKeys = Object.keys(migrations).map(function (ver) {
        return parseInt(ver);
      }).filter(function (key) {
        return currentVersion >= key && key > inboundVersion;
      }).sort(function (a, b) {
        return a - b;
      });
      if ( debug) console.log('redux-persist: migrationKeys', migrationKeys);

      try {
        var migratedState = migrationKeys.reduce(function (state, versionKey) {
          if ("development" !== 'production' && debug) console.log('redux-persist: running migration for versionKey', versionKey);
          return migrations[versionKey](state);
        }, state);
        return Promise.resolve(migratedState);
      } catch (err) {
        return Promise.reject(err);
      }
    };
  }

  function createTransform( // @NOTE inbound: transform state coming from redux on its way to being serialized and stored
  inbound, // @NOTE outbound: transform state coming from storage, on its way to be rehydrated into redux
  outbound) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var whitelist = config.whitelist || null;
    var blacklist = config.blacklist || null;

    function whitelistBlacklistCheck(key) {
      if (whitelist && whitelist.indexOf(key) === -1) return true;
      if (blacklist && blacklist.indexOf(key) !== -1) return true;
      return false;
    }

    return {
      "in": function _in(state, key, fullState) {
        return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;
      },
      out: function out(state, key, fullState) {
        return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;
      }
    };
  }

  exports.DEFAULT_VERSION = DEFAULT_VERSION;
  exports.FLUSH = FLUSH;
  exports.KEY_PREFIX = KEY_PREFIX;
  exports.PAUSE = PAUSE;
  exports.PERSIST = PERSIST;
  exports.PURGE = PURGE;
  exports.REGISTER = REGISTER;
  exports.REHYDRATE = REHYDRATE;
  exports.createMigrate = createMigrate;
  exports.createPersistoid = createPersistoid;
  exports.createTransform = createTransform;
  exports.getStoredState = getStoredState;
  exports.persistCombineReducers = persistCombineReducers;
  exports.persistReducer = persistReducer;
  exports.persistStore = persistStore;
  exports.purgeStoredState = purgeStoredState;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=redux-persist.js.map
